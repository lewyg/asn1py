# Code automatically generated by asn1scc tool

import asn1


class MyBool(asn1.Boolean):
    """Derived from Boolean"""

    def init_value(self):
        return False

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 1

    def uper_encode(self, bit_stream):
        bit_stream.append_bit(int(self._value))

    def uper_decode(self, bit_stream):
        value = bit_stream.read_bit()

        self.set(value)


class MyNull(asn1.Null):
    """Derived from Null"""

    def init_value(self):
        return None


class MyInt(asn1.PosInteger):
    """Derived from PosInteger"""

    def init_value(self):
        return 0

    __constraints__ = 'value <= 100'

    def check_constraints(self, value):
        return value <= 100

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 7

    def uper_encode(self, bit_stream):
        bit_stream.encode_constraint_number(self._value, 0, 100)

    def uper_decode(self, bit_stream):
        value = bit_stream.decode_constraint_number(0, 100)

        self.set(value)


class MyInt2(asn1.Integer):
    """Derived from Integer"""

    def init_value(self):
        return 5

    __constraints__ = '((5 <= value and value <= 40) or (60 <= value and value <= 70))'

    def check_constraints(self, value):
        return ((5 <= value and value <= 40) or (60 <= value and value <= 70))

    REQUIRED_BYTES_FOR_ENCODING = 10
    REQUIRED_BITS_FOR_ENCODING = 73

    def uper_encode(self, bit_stream):
        if (5 <= self._value and self._value <= 40):
            bit_stream.append_bit_zero()  # write extension bit, value within root range, so ext bit is zero
            bit_stream.encode_constraint_number(self._value, 5, 40)
        else:
            # value is not within root range, so ext bit is one and value is encoded as uncostraint
            bit_stream.append_bit_one()
            bit_stream.encode_number(self._value)

    def uper_decode(self, bit_stream):
        ext_bit = bit_stream.read_bit()
        if ext_bit:
            value = bit_stream.decode_number()  # COVERAGE_IGNORE
        else:
            value = bit_stream.decode_constraint_number(5, 40)

        self.set(value)


class MyIntArr(asn1.SequenceOf[int]):
    """Derived from SequenceOf"""

    def init_value(self):
        return 10  # init length

    REQUIRED_BYTES_FOR_ENCODING = 90
    REQUIRED_BITS_FOR_ENCODING = 720

    def uper_encode(self, bit_stream):
        for i1 in range(10):
            self._list[i1].uper_encode(bit_stream)

    def uper_decode(self, bit_stream):
        value_i1 = list()

        for i1 in range(10):
            elem = self.ElementType()
            elem.uper_decode(bit_stream)
            value_i1.append(elem)

        value = value_i1

        self.set(value)

    class ElementType(asn1.Integer):
        """Derived from Integer"""

        def init_value(self):
            return 0

        REQUIRED_BYTES_FOR_ENCODING = 9
        REQUIRED_BITS_FOR_ENCODING = 72

        def uper_encode(self, bit_stream):
            bit_stream.encode_number(self._value)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_number()

            self.set(value)


class MyStr(asn1.IA5String):
    """Derived from IA5String"""

    def init_value(self):
        return 'A'

    __constraints__ = '(1 <= len(value) and len(value) <= 10) and self._check_alphabet(value)'

    def _check_alphabet(self, value):
        for char in value:
            if not (('A' <= char and char <= 'Z') or char == 'abcde'):
                return False
        return True

    def check_constraints(self, value):
        return (1 <= len(value) and len(value) <= 10) and self._check_alphabet(value)

    REQUIRED_BYTES_FOR_ENCODING = 7
    REQUIRED_BITS_FOR_ENCODING = 54

    def uper_encode(self, bit_stream):
        bit_stream.encode_constraint_number(len(self._value), 1, 10)

        for i1 in range(len(self._value)):
            allowed_charset = ['\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47', '\x48',
                               '\x49', '\x4A', '\x4B', '\x4C', '\x4D', '\x4E', '\x4F', '\x50',
                               '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57', '\x58',
                               '\x59', '\x5A', '\x61', '\x62', '\x63', '\x64', '\x65']
            index = allowed_charset.index(self._value[i1])
            bit_stream.encode_constraint_number(index, 0, 31)

    def uper_decode(self, bit_stream):
        value_i1 = ''
        length = bit_stream.decode_constraint_number(1, 10)

        for i1 in range(length):
            allowed_charset = ['\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47', '\x48',
                               '\x49', '\x4A', '\x4B', '\x4C', '\x4D', '\x4E', '\x4F', '\x50',
                               '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57', '\x58',
                               '\x59', '\x5A', '\x61', '\x62', '\x63', '\x64', '\x65']
            index = bit_stream.decode_constraint_number(0, 31)
            char = allowed_charset[index]
            value_i1 += char

        value = value_i1

        self.set(value)


class MyNumStr(asn1.NumericString):
    """Derived from NumericString"""

    def init_value(self):
        return '   '

    __constraints__ = 'len(value) == 3'

    def check_constraints(self, value):
        return len(value) == 3

    REQUIRED_BYTES_FOR_ENCODING = 2
    REQUIRED_BITS_FOR_ENCODING = 12

    def uper_encode(self, bit_stream):
        for i1 in range(3):
            allowed_charset = ['\x20', '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36',
                               '\x37', '\x38', '\x39']
            index = allowed_charset.index(self._value[i1])
            bit_stream.encode_constraint_number(index, 0, 11)

    def uper_decode(self, bit_stream):
        value_i1 = ''

        for i1 in range(3):
            allowed_charset = ['\x20', '\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36',
                               '\x37', '\x38', '\x39']
            index = bit_stream.decode_constraint_number(0, 11)
            char = allowed_charset[index]
            value_i1 += char

        value = value_i1

        self.set(value)


class MyBit(asn1.BitString):
    """Derived from BitString"""

    def init_value(self):
        return '0000000000000000'

    __constraints__ = 'len(value) == 16'

    def check_constraints(self, value):
        return len(value) == 16

    REQUIRED_BYTES_FOR_ENCODING = 16
    REQUIRED_BITS_FOR_ENCODING = 128

    def uper_encode(self, bit_stream):
        bit_stream.append_bits(self._value, 16)

    def uper_decode(self, bit_stream):
        value = bit_stream.read_bitarray(16)

        self.set(value)


class MyOct(asn1.OctetString):
    """Derived from OctetString"""

    def init_value(self):
        return b'\x00\x00\x00'

    __constraints__ = '(3 <= len(value) and len(value) <= 8)'

    def check_constraints(self, value):
        return (3 <= len(value) and len(value) <= 8)

    REQUIRED_BYTES_FOR_ENCODING = 9
    REQUIRED_BITS_FOR_ENCODING = 67

    def uper_encode(self, bit_stream):
        bit_stream.encode_constraint_number(len(self._value), 3, 8)

        for i1 in range(len(self._value)):
            bit_stream.append_byte(self._value[i1])

    def uper_decode(self, bit_stream):
        value_i1 = bytearray()
        length = bit_stream.decode_constraint_number(3, 8)

        for i1 in range(length):
            byte = bit_stream.read_byte()
            value_i1.append(byte)

        value = value_i1

        self.set(value)


class MyReal(asn1.Real):
    """Derived from Real"""

    def init_value(self):
        return 1.00000000000000000000E+001

    __constraints__ = '((1.00000000000000000000E+001 <= value and value <= 2.00000000000000000000E+001) or (2.50000000000000000000E+001 <= value and value <= 2.60000000000000000000E+001))'

    def check_constraints(self, value):
        return ((1.00000000000000000000E+001 <= value and value <= 2.00000000000000000000E+001) or (2.50000000000000000000E+001 <= value and value <= 2.60000000000000000000E+001))

    REQUIRED_BYTES_FOR_ENCODING = 13
    REQUIRED_BITS_FOR_ENCODING = 104

    def uper_encode(self, bit_stream):
        bit_stream.encode_real(self._value)

    def uper_decode(self, bit_stream):
        value = bit_stream.decode_real()

        self.set(value)


class MyEnum(asn1.Enumerated):
    """Derived from Enumerated"""

    class Value(asn1.Enumerated.Value):
        NONE = None
        alpha = 0
        beta = 1
        gamma = 2

    __simple__ = Value

    def init_value(self):
        return self.Value.alpha

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 2

    def uper_encode(self, bit_stream):
        if self._value == self.Value.alpha:
            bit_stream.encode_constraint_number(0, 0, 2)

        elif self._value == self.Value.beta:
            bit_stream.encode_constraint_number(1, 0, 2)

        elif self._value == self.Value.gamma:
            bit_stream.encode_constraint_number(2, 0, 2)

    def uper_decode(self, bit_stream):
        enum_index = bit_stream.decode_constraint_number(0, 2)

        if enum_index == 0:
            value = self.Value.alpha

        elif enum_index == 1:
            value = self.Value.beta

        elif enum_index == 2:
            value = self.Value.gamma

        else:
            raise asn1.UnexpectedOptionIndex(type(self), enum_index)

        self.set(value)


class MyStruct(asn1.Sequence):
    """Derived from Sequence"""

    __optionals__ = ["b"]

    @property
    def a_0(self):
        self._assert_attribute_present('a_0')
        return self._a_0.get()

    @a_0.setter
    def a_0(self, value):
        self._a_0.set(value)

    @a_0.deleter
    def a_0(self):
        pass

    @property
    def b(self):
        self._assert_attribute_present('b')
        return self._b.get()

    @b.setter
    def b(self, value):
        self._b.set(value)

    @b.deleter
    def b(self):
        pass

    @property
    def c(self):
        self._assert_attribute_present('c')
        return self._c.get()

    @c.setter
    def c(self, value):
        self._c.set(value)

    @c.deleter
    def c(self):
        pass

    def __init__(self, source=None):
        self.__attributes__ = dict(
            a_0=True,
            b=True,
            c=True
        )

        self._a_0 = self.a_0Type()
        self._b = self.bType()
        self._c = self.cType()

        self.__initialized__ = True
        self._init_sequence(source)

    def init_value(self):
        return None

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 6

    def uper_encode(self, bit_stream):
        bit_stream.append_bit(self.get_attribute_exists('b'))

        # Encode a_0
        self._a_0.uper_encode(bit_stream)

        # Encode c
        self._c.uper_encode(bit_stream)

    def uper_decode(self, bit_stream):
        self.set_attribute_exists('b', bool(bit_stream.read_bit()))

        # Decode a_0
        self._a_0.uper_decode(bit_stream)

        # Decode c
        self._c.uper_decode(bit_stream)

    class a_0Type(asn1.PosInteger):
        """Derived from PosInteger"""

        def init_value(self):
            return 1

        __constraints__ = '(1 <= value and value <= 10)'

        def check_constraints(self, value):
            return (1 <= value and value <= 10)

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 4

        def uper_encode(self, bit_stream):
            bit_stream.encode_constraint_number(self._value, 1, 10)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_constraint_number(1, 10)

            self.set(value)

    class bType(asn1.Null):
        """Derived from Null"""

        def init_value(self):
            return None

    class cType(asn1.Boolean):
        """Derived from Boolean"""

        def init_value(self):
            return False

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 1

        def uper_encode(self, bit_stream):
            bit_stream.append_bit(int(self._value))

        def uper_decode(self, bit_stream):
            value = bit_stream.read_bit()

            self.set(value)


class MyChoice(asn1.Choice):
    """Derived from Choice"""

    @property
    def alpha_0(self):
        self._assert_attribute_present('alpha_0')
        return self._alpha_0.get()

    @alpha_0.setter
    def alpha_0(self, value):
        self._alpha_0.set(value)

    @alpha_0.deleter
    def alpha_0(self):
        pass

    @property
    def beta(self):
        self._assert_attribute_present('beta')
        return self._beta.get()

    @beta.setter
    def beta(self, value):
        self._beta.set(value)

    @beta.deleter
    def beta(self):
        pass

    @property
    def octStr(self):
        self._assert_attribute_present('octStr')
        return self._octStr.get()

    @octStr.setter
    def octStr(self, value):
        self._octStr.set(value)

    @octStr.deleter
    def octStr(self):
        pass

    def __init__(self, source=None):
        self.__attributes__ = dict(
            alpha_0=False,
            beta=False,
            octStr=False
        )

        self._alpha_0 = self.alpha_0Type()
        self._beta = self.betaType()
        self._octStr = self.octStrType()

        self.__initialized__ = True
        self._init_choice(source)

    def init_value(self):
        return None

    REQUIRED_BYTES_FOR_ENCODING = 10
    REQUIRED_BITS_FOR_ENCODING = 74

    def uper_encode(self, bit_stream):
        if self.get_attribute_exists('alpha_0'):
            bit_stream.encode_constraint_number(0, 0, 2)
            self._alpha_0.uper_encode(bit_stream)

        elif self.get_attribute_exists('beta'):
            bit_stream.encode_constraint_number(1, 0, 2)
            self._beta.uper_encode(bit_stream)

        elif self.get_attribute_exists('octStr'):
            bit_stream.encode_constraint_number(2, 0, 2)
            self._octStr.uper_encode(bit_stream)

        else:
            raise asn1.UnexpectedValueException(type(self), 'NONE')

    def uper_decode(self, bit_stream):
        child_index = bit_stream.decode_constraint_number(0, 2)

        if child_index == 0:
            self._alpha_0.uper_decode(bit_stream)

        elif child_index == 1:
            self._beta.uper_decode(bit_stream)

        elif child_index == 2:
            self._octStr.uper_decode(bit_stream)

        else:
            raise asn1.UnexpectedOptionIndex(type(self), child_index)

    class alpha_0Type(MyStruct):
        """Ref from MyStruct"""

        def init_value(self):
            return None

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 6

        def uper_encode(self, bit_stream):
            super().uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            super().uper_decode(bit_stream)

    class betaType(asn1.Integer):
        """Derived from Integer"""

        def init_value(self):
            return 0

        REQUIRED_BYTES_FOR_ENCODING = 9
        REQUIRED_BITS_FOR_ENCODING = 72

        def uper_encode(self, bit_stream):
            bit_stream.encode_number(self._value)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_number()

            self.set(value)

    class octStrType(asn1.OctetString):
        """Derived from OctetString"""

        def init_value(self):
            return b'\x00\x00\x00\x00'

        __constraints__ = 'len(value) == 4'

        def check_constraints(self, value):
            return len(value) == 4

        REQUIRED_BYTES_FOR_ENCODING = 4
        REQUIRED_BITS_FOR_ENCODING = 32

        def uper_encode(self, bit_stream):
            for i1 in range(4):
                bit_stream.append_byte(self._value[i1])

        def uper_decode(self, bit_stream):
            value_i1 = bytearray()

            for i1 in range(4):
                byte = bit_stream.read_byte()
                value_i1.append(byte)

            value = value_i1

            self.set(value)


class MySqOf(asn1.SequenceOf['MySqOf.ElementType']):
    """Derived from SequenceOf"""

    def init_value(self):
        return 1  # init length

    __constraints__ = '((1 <= len(value) and len(value) <= 20) or len(value) == 25)'

    def check_constraints(self, value):
        return ((1 <= len(value) and len(value) <= 20) or len(value) == 25)

    REQUIRED_BYTES_FOR_ENCODING = 570
    REQUIRED_BITS_FOR_ENCODING = 4555

    def uper_encode(self, bit_stream):
        bit_stream.encode_constraint_number(len(self), 1, 25)

        for i1 in range(len(self)):
            self._list[i1].uper_encode(bit_stream)

    def uper_decode(self, bit_stream):
        length = bit_stream.decode_constraint_number(1, 25)
        value_i1 = list()

        for i1 in range(length):
            elem = self.ElementType()
            elem.uper_decode(bit_stream)
            value_i1.append(elem)

        value = value_i1

        self.set(value)

    class ElementType(asn1.Sequence):
        """Derived from Sequence"""

        __optionals__ = ["b2", "c2"]

        @property
        def a2(self):
            self._assert_attribute_present('a2')
            return self._a2.get()

        @a2.setter
        def a2(self, value):
            self._a2.set(value)

        @a2.deleter
        def a2(self):
            pass

        @property
        def b2(self):
            self._assert_attribute_present('b2')
            return self._b2.get()

        @b2.setter
        def b2(self, value):
            self._b2.set(value)

        @b2.deleter
        def b2(self):
            pass

        @property
        def c2(self):
            self._assert_attribute_present('c2')
            return self._c2.get()

        @c2.setter
        def c2(self, value):
            self._c2.set(value)

        @c2.deleter
        def c2(self):
            pass

        def __init__(self, source=None):
            self.__attributes__ = dict(
                a2=True,
                b2=True,
                c2=True
            )

            self._a2 = self.a2Type()
            self._b2 = self.b2Type()
            self._c2 = self.c2Type()

            self.__initialized__ = True
            self._init_sequence(source)

        def init_value(self):
            return None

        REQUIRED_BYTES_FOR_ENCODING = 23
        REQUIRED_BITS_FOR_ENCODING = 182

        def uper_encode(self, bit_stream):
            bit_stream.append_bit(self.get_attribute_exists('b2'))

            bit_stream.append_bit(self.get_attribute_exists('c2'))

            # Encode a2
            self._a2.uper_encode(bit_stream)

            # Encode b2
            if self.get_attribute_exists('b2'):
                self._b2.uper_encode(bit_stream)

            # Encode c2
            if self.get_attribute_exists('c2'):
                self._c2.uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            self.set_attribute_exists('b2', bool(bit_stream.read_bit()))

            self.set_attribute_exists('c2', bool(bit_stream.read_bit()))

            # Decode a2
            self._a2.uper_decode(bit_stream)

            # Decode b2
            if self.get_attribute_exists('b2'):
                self._b2.uper_decode(bit_stream)

            # Decode c2
            if self.get_attribute_exists('c2'):
                self._c2.uper_decode(bit_stream)

        class a2Type(asn1.PosInteger):
            """Derived from PosInteger"""

            def init_value(self):
                return 1

            __constraints__ = '(1 <= value and value <= 10)'

            def check_constraints(self, value):
                return (1 <= value and value <= 10)

            REQUIRED_BYTES_FOR_ENCODING = 1
            REQUIRED_BITS_FOR_ENCODING = 4

            def uper_encode(self, bit_stream):
                bit_stream.encode_constraint_number(self._value, 1, 10)

            def uper_decode(self, bit_stream):
                value = bit_stream.decode_constraint_number(1, 10)

                self.set(value)

        class b2Type(asn1.Real):
            """Derived from Real"""

            def init_value(self):
                return 0.00000000000000000000E+000

            REQUIRED_BYTES_FOR_ENCODING = 13
            REQUIRED_BITS_FOR_ENCODING = 104

            def uper_encode(self, bit_stream):
                bit_stream.encode_real(self._value)

            def uper_decode(self, bit_stream):
                value = bit_stream.decode_real()

                self.set(value)

        class c2Type(asn1.Integer):
            """Derived from Integer"""

            def init_value(self):
                return 0

            REQUIRED_BYTES_FOR_ENCODING = 9
            REQUIRED_BITS_FOR_ENCODING = 72

            def uper_encode(self, bit_stream):
                bit_stream.encode_number(self._value)

            def uper_decode(self, bit_stream):
                value = bit_stream.decode_number()

                self.set(value)


class TypeEnumerated(asn1.Enumerated):
    """Derived from Enumerated"""

    class Value(asn1.Enumerated.Value):
        NONE = None
        red = 0
        green = 1
        blue = 2

    __simple__ = Value

    def init_value(self):
        return self.Value.red

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 2

    def uper_encode(self, bit_stream):
        if self._value == self.Value.red:
            bit_stream.encode_constraint_number(0, 0, 2)

        elif self._value == self.Value.green:
            bit_stream.encode_constraint_number(1, 0, 2)

        elif self._value == self.Value.blue:
            bit_stream.encode_constraint_number(2, 0, 2)

    def uper_decode(self, bit_stream):
        enum_index = bit_stream.decode_constraint_number(0, 2)

        if enum_index == 0:
            value = self.Value.red

        elif enum_index == 1:
            value = self.Value.green

        elif enum_index == 2:
            value = self.Value.blue

        else:
            raise asn1.UnexpectedOptionIndex(type(self), enum_index)

        self.set(value)


class My2ndEnumerated(TypeEnumerated):
    """Ref from TypeEnumerated"""

    def init_value(self):
        return self.Value.red

    REQUIRED_BYTES_FOR_ENCODING = 1
    REQUIRED_BITS_FOR_ENCODING = 2

    def uper_encode(self, bit_stream):
        super().uper_encode(bit_stream)

    def uper_decode(self, bit_stream):
        super().uper_decode(bit_stream)


class AComplexMessage(asn1.Sequence):
    """Derived from Sequence"""

    __optionals__ = []

    @property
    def intVal(self):
        self._assert_attribute_present('intVal')
        return self._intVal.get()

    @intVal.setter
    def intVal(self, value):
        self._intVal.set(value)

    @intVal.deleter
    def intVal(self):
        pass

    @property
    def int2Val(self):
        self._assert_attribute_present('int2Val')
        return self._int2Val.get()

    @int2Val.setter
    def int2Val(self, value):
        self._int2Val.set(value)

    @int2Val.deleter
    def int2Val(self):
        pass

    @property
    def int3Val(self):
        self._assert_attribute_present('int3Val')
        return self._int3Val.get()

    @int3Val.setter
    def int3Val(self, value):
        self._int3Val.set(value)

    @int3Val.deleter
    def int3Val(self):
        pass

    @property
    def strVal(self):
        self._assert_attribute_present('strVal')
        return self._strVal.get()

    @strVal.setter
    def strVal(self, value):
        self._strVal.set(value)

    @strVal.deleter
    def strVal(self):
        pass

    @property
    def intArray(self):
        self._assert_attribute_present('intArray')
        return self._intArray.get()

    @intArray.setter
    def intArray(self, value):
        self._intArray.set(value)

    @intArray.deleter
    def intArray(self):
        pass

    @property
    def realArray(self):
        self._assert_attribute_present('realArray')
        return self._realArray.get()

    @realArray.setter
    def realArray(self, value):
        self._realArray.set(value)

    @realArray.deleter
    def realArray(self):
        pass

    @property
    def octStrArray(self):
        self._assert_attribute_present('octStrArray')
        return self._octStrArray.get()

    @octStrArray.setter
    def octStrArray(self, value):
        self._octStrArray.set(value)

    @octStrArray.deleter
    def octStrArray(self):
        pass

    @property
    def enumArray(self):
        self._assert_attribute_present('enumArray')
        return self._enumArray.get()

    @enumArray.setter
    def enumArray(self, value):
        self._enumArray.set(value)

    @enumArray.deleter
    def enumArray(self):
        pass

    @property
    def enumValue(self):
        self._assert_attribute_present('enumValue')
        return self._enumValue.get()

    @enumValue.setter
    def enumValue(self, value):
        self._enumValue.set(value)

    @enumValue.deleter
    def enumValue(self):
        pass

    @property
    def sqVal(self):
        self._assert_attribute_present('sqVal')
        return self._sqVal.get()

    @sqVal.setter
    def sqVal(self, value):
        self._sqVal.set(value)

    @sqVal.deleter
    def sqVal(self):
        pass

    @property
    def enumValue2(self):
        self._assert_attribute_present('enumValue2')
        return self._enumValue2.get()

    @enumValue2.setter
    def enumValue2(self, value):
        self._enumValue2.set(value)

    @enumValue2.deleter
    def enumValue2(self):
        pass

    @property
    def label(self):
        self._assert_attribute_present('label')
        return self._label.get()

    @label.setter
    def label(self, value):
        self._label.set(value)

    @label.deleter
    def label(self):
        pass

    @property
    def bAlpha(self):
        self._assert_attribute_present('bAlpha')
        return self._bAlpha.get()

    @bAlpha.setter
    def bAlpha(self, value):
        self._bAlpha.set(value)

    @bAlpha.deleter
    def bAlpha(self):
        pass

    @property
    def bBeta(self):
        self._assert_attribute_present('bBeta')
        return self._bBeta.get()

    @bBeta.setter
    def bBeta(self, value):
        self._bBeta.set(value)

    @bBeta.deleter
    def bBeta(self):
        pass

    def __init__(self, source=None):
        self.__attributes__ = dict(
            intVal=True,
            int2Val=True,
            int3Val=True,
            strVal=True,
            intArray=True,
            realArray=True,
            octStrArray=True,
            enumArray=True,
            enumValue=True,
            sqVal=True,
            enumValue2=True,
            label=True,
            bAlpha=True,
            bBeta=True
        )

        self._intVal = self.intValType()
        self._int2Val = self.int2ValType()
        self._int3Val = self.int3ValType()
        self._strVal = self.strValType()
        self._intArray = self.intArrayType()
        self._realArray = self.realArrayType()
        self._octStrArray = self.octStrArrayType()
        self._enumArray = self.enumArrayType()
        self._enumValue = self.enumValueType()
        self._sqVal = self.sqValType()
        self._enumValue2 = self.enumValue2Type()
        self._label = self.labelType()
        self._bAlpha = self.bAlphaType()
        self._bBeta = self.bBetaType()

        self.__initialized__ = True
        self._init_sequence(source)

    def init_value(self):
        return None

    REQUIRED_BYTES_FOR_ENCODING = 461
    REQUIRED_BITS_FOR_ENCODING = 3684

    def uper_encode(self, bit_stream):
        # Encode intVal
        self._intVal.uper_encode(bit_stream)

        # Encode int2Val
        self._int2Val.uper_encode(bit_stream)

        # Encode int3Val
        self._int3Val.uper_encode(bit_stream)

        # Encode strVal
        self._strVal.uper_encode(bit_stream)

        # Encode intArray
        self._intArray.uper_encode(bit_stream)

        # Encode realArray
        self._realArray.uper_encode(bit_stream)

        # Encode octStrArray
        self._octStrArray.uper_encode(bit_stream)

        # Encode enumArray
        self._enumArray.uper_encode(bit_stream)

        # Encode enumValue
        self._enumValue.uper_encode(bit_stream)

        # Encode sqVal
        self._sqVal.uper_encode(bit_stream)

        # Encode enumValue2
        self._enumValue2.uper_encode(bit_stream)

        # Encode label
        self._label.uper_encode(bit_stream)

        # Encode bBeta
        self._bBeta.uper_encode(bit_stream)

    def uper_decode(self, bit_stream):
        # Decode intVal
        self._intVal.uper_decode(bit_stream)

        # Decode int2Val
        self._int2Val.uper_decode(bit_stream)

        # Decode int3Val
        self._int3Val.uper_decode(bit_stream)

        # Decode strVal
        self._strVal.uper_decode(bit_stream)

        # Decode intArray
        self._intArray.uper_decode(bit_stream)

        # Decode realArray
        self._realArray.uper_decode(bit_stream)

        # Decode octStrArray
        self._octStrArray.uper_decode(bit_stream)

        # Decode enumArray
        self._enumArray.uper_decode(bit_stream)

        # Decode enumValue
        self._enumValue.uper_decode(bit_stream)

        # Decode sqVal
        self._sqVal.uper_decode(bit_stream)

        # Decode enumValue2
        self._enumValue2.uper_decode(bit_stream)

        # Decode label
        self._label.uper_decode(bit_stream)

        # Decode bBeta
        self._bBeta.uper_decode(bit_stream)

    class intValType(asn1.PosInteger):
        """Derived from PosInteger"""

        def init_value(self):
            return 0

        __constraints__ = 'value <= 10'

        def check_constraints(self, value):
            return value <= 10

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 4

        def uper_encode(self, bit_stream):
            bit_stream.encode_constraint_number(self._value, 0, 10)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_constraint_number(0, 10)

            self.set(value)

    class int2ValType(asn1.Integer):
        """Derived from Integer"""

        def init_value(self):
            return -10

        __constraints__ = '(-10 <= value and value <= 10)'

        def check_constraints(self, value):
            return (-10 <= value and value <= 10)

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 5

        def uper_encode(self, bit_stream):
            bit_stream.encode_constraint_number(self._value, -10, 10)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_constraint_number(-10, 10)

            self.set(value)

    class int3ValType(MyInt):
        """Ref from MyInt"""

        def init_value(self):
            return 10

        __constraints__ = 'value <= 100 and (10 <= value and value <= 12)'

        def check_constraints(self, value):
            return value <= 100 and (10 <= value and value <= 12)

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 2

        def uper_encode(self, bit_stream):
            bit_stream.encode_constraint_number(self._value, 10, 12)

        def uper_decode(self, bit_stream):
            value = bit_stream.decode_constraint_number(10, 12)

            self.set(value)

    class strValType(MyStr):
        """Ref from MyStr"""

        def init_value(self):
            return 'A'

        __constraints__ = '(1 <= len(value) and len(value) <= 10) and self._check_alphabet(value)'

        def _check_alphabet(self, value):
            for char in value:
                if not (('A' <= char and char <= 'Z') or char == 'abcde'):
                    return False
            return True

        def check_constraints(self, value):
            return (1 <= len(value) and len(value) <= 10) and self._check_alphabet(value)

        REQUIRED_BYTES_FOR_ENCODING = 7
        REQUIRED_BITS_FOR_ENCODING = 54

        def uper_encode(self, bit_stream):
            super().uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            super().uper_decode(bit_stream)

    class intArrayType(asn1.SequenceOf[int]):
        """Derived from SequenceOf"""

        def init_value(self):
            return 10  # init length

        __constraints__ = 'len(value) == 10'

        def check_constraints(self, value):
            return len(value) == 10

        REQUIRED_BYTES_FOR_ENCODING = 3
        REQUIRED_BITS_FOR_ENCODING = 20

        def uper_encode(self, bit_stream):
            for i1 in range(10):
                self._list[i1].uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            value_i1 = list()

            for i1 in range(10):
                elem = self.ElementType()
                elem.uper_decode(bit_stream)
                value_i1.append(elem)

            value = value_i1

            self.set(value)

        class ElementType(asn1.PosInteger):
            """Derived from PosInteger"""

            def init_value(self):
                return 0

            __constraints__ = 'value <= 3'

            def check_constraints(self, value):
                return value <= 3

            REQUIRED_BYTES_FOR_ENCODING = 1
            REQUIRED_BITS_FOR_ENCODING = 2

            def uper_encode(self, bit_stream):
                bit_stream.encode_constraint_number(self._value, 0, 3)

            def uper_decode(self, bit_stream):
                value = bit_stream.decode_constraint_number(0, 3)

                self.set(value)

    class realArrayType(asn1.SequenceOf[float]):
        """Derived from SequenceOf"""

        def init_value(self):
            return 15  # init length

        __constraints__ = 'len(value) == 15'

        def check_constraints(self, value):
            return len(value) == 15

        REQUIRED_BYTES_FOR_ENCODING = 195
        REQUIRED_BITS_FOR_ENCODING = 1560

        def uper_encode(self, bit_stream):
            for i1 in range(15):
                self._list[i1].uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            value_i1 = list()

            for i1 in range(15):
                elem = self.ElementType()
                elem.uper_decode(bit_stream)
                value_i1.append(elem)

            value = value_i1

            self.set(value)

        class ElementType(asn1.Real):
            """Derived from Real"""

            def init_value(self):
                return 1.00000000000000010000E-001

            __constraints__ = '(1.00000000000000010000E-001 <= value and value <= 3.14000000000000010000E+000)'

            def check_constraints(self, value):
                return (1.00000000000000010000E-001 <= value and value <= 3.14000000000000010000E+000)

            REQUIRED_BYTES_FOR_ENCODING = 13
            REQUIRED_BITS_FOR_ENCODING = 104

            def uper_encode(self, bit_stream):
                bit_stream.encode_real(self._value)

            def uper_decode(self, bit_stream):
                value = bit_stream.decode_real()

                self.set(value)

    class octStrArrayType(asn1.SequenceOf[bytearray]):
        """Derived from SequenceOf"""

        def init_value(self):
            return 20  # init length

        __constraints__ = 'len(value) == 20'

        def check_constraints(self, value):
            return len(value) == 20

        REQUIRED_BYTES_FOR_ENCODING = 210
        REQUIRED_BITS_FOR_ENCODING = 1680

        def uper_encode(self, bit_stream):
            for i1 in range(20):
                self._list[i1].uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            value_i1 = list()

            for i1 in range(20):
                elem = self.ElementType()
                elem.uper_decode(bit_stream)
                value_i1.append(elem)

            value = value_i1

            self.set(value)

        class ElementType(asn1.OctetString):
            """Derived from OctetString"""

            def init_value(self):
                return b'\x00'

            __constraints__ = '(1 <= len(value) and len(value) <= 10)'

            def check_constraints(self, value):
                return (1 <= len(value) and len(value) <= 10)

            REQUIRED_BYTES_FOR_ENCODING = 11
            REQUIRED_BITS_FOR_ENCODING = 84

            def uper_encode(self, bit_stream):
                bit_stream.encode_constraint_number(len(self._value), 1, 10)

                for i2 in range(len(self._value)):
                    bit_stream.append_byte(self._value[i2])

            def uper_decode(self, bit_stream):
                value_i2 = bytearray()
                length = bit_stream.decode_constraint_number(1, 10)

                for i2 in range(length):
                    byte = bit_stream.read_byte()
                    value_i2.append(byte)

                value = value_i2

                self.set(value)

    class enumArrayType(asn1.SequenceOf[asn1.Enum]):
        """Derived from SequenceOf"""

        def init_value(self):
            return 12  # init length

        REQUIRED_BYTES_FOR_ENCODING = 3
        REQUIRED_BITS_FOR_ENCODING = 24

        def uper_encode(self, bit_stream):
            for i1 in range(12):
                self._list[i1].uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            value_i1 = list()

            for i1 in range(12):
                elem = self.ElementType()
                elem.uper_decode(bit_stream)
                value_i1.append(elem)

            value = value_i1

            self.set(value)

        class ElementType(TypeEnumerated):
            """Ref from TypeEnumerated"""

            def init_value(self):
                return self.Value.red

            REQUIRED_BYTES_FOR_ENCODING = 1
            REQUIRED_BITS_FOR_ENCODING = 2

            def uper_encode(self, bit_stream):
                super().uper_encode(bit_stream)

            def uper_decode(self, bit_stream):
                super().uper_decode(bit_stream)

    class enumValueType(TypeEnumerated):
        """Ref from TypeEnumerated"""

        def init_value(self):
            return self.Value.red

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 2

        def uper_encode(self, bit_stream):
            super().uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            super().uper_decode(bit_stream)

    class sqValType(MyStruct):
        """Ref from MyStruct"""

        def init_value(self):
            return None

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 6

        def uper_encode(self, bit_stream):
            super().uper_encode(bit_stream)

        def uper_decode(self, bit_stream):
            super().uper_decode(bit_stream)

    class enumValue2Type(asn1.Enumerated):
        """Derived from Enumerated"""

        class Value(asn1.Enumerated.Value):
            NONE = None
            truism = 0
            falsism = 1

        __simple__ = Value

        def init_value(self):
            return self.Value.truism

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 1

        def uper_encode(self, bit_stream):
            if self._value == self.Value.truism:
                bit_stream.encode_constraint_number(0, 0, 1)

            elif self._value == self.Value.falsism:
                bit_stream.encode_constraint_number(1, 0, 1)

        def uper_decode(self, bit_stream):
            enum_index = bit_stream.decode_constraint_number(0, 1)

            if enum_index == 0:
                value = self.Value.truism

            elif enum_index == 1:
                value = self.Value.falsism

            else:
                raise asn1.UnexpectedOptionIndex(type(self), enum_index)

            self.set(value)

    class labelType(asn1.OctetString):
        """Derived from OctetString"""

        def init_value(self):
            return b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

        __constraints__ = '(10 <= len(value) and len(value) <= 40)'

        def check_constraints(self, value):
            return (10 <= len(value) and len(value) <= 40)

        REQUIRED_BYTES_FOR_ENCODING = 41
        REQUIRED_BITS_FOR_ENCODING = 325

        def uper_encode(self, bit_stream):
            bit_stream.encode_constraint_number(len(self._value), 10, 40)

            for i1 in range(len(self._value)):
                bit_stream.append_byte(self._value[i1])

        def uper_decode(self, bit_stream):
            value_i1 = bytearray()
            length = bit_stream.decode_constraint_number(10, 40)

            for i1 in range(length):
                byte = bit_stream.read_byte()
                value_i1.append(byte)

            value = value_i1

            self.set(value)

    class bAlphaType(asn1.Null):
        """Derived from Null"""

        def init_value(self):
            return None

    class bBetaType(asn1.Boolean):
        """Derived from Boolean"""

        def init_value(self):
            return False

        REQUIRED_BYTES_FOR_ENCODING = 1
        REQUIRED_BITS_FOR_ENCODING = 1

        def uper_encode(self, bit_stream):
            bit_stream.append_bit(int(self._value))

        def uper_decode(self, bit_stream):
            value = bit_stream.read_bit()

            self.set(value)


vMyBool = MyBool(True)
vMyInt = MyInt(88)
v2MyInt = MyInt(vMyInt)
vMyIntArr = MyIntArr([
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10
])
vMyStr = MyStr('AAABBC')
vMyNumStr = MyNumStr('123')
vMyBit = MyBit('1111111110101100')
vMyOct = MyOct(b'\x12\x34\x56\x78')
vMyReal = MyReal(1.71230000000000010000E+001)
vMyEnum = MyEnum(MyEnum.Value.alpha)
vMyStruct = MyStruct(dict(
    a_0=2,
    c=True
))
vMyChoice = MyChoice(dict(
    name='alpha_0',
    value=dict(
    a_0=2,
    b=None,
    c=True
)
))
b = asn1.BitStream()


vMyChoice.encode(b, 'uper')
print(vMyChoice)
b2 = asn1.BitStream(b)
print(b2)

y = MyChoice()
y.decode(b2, 'uper')

print(y)